--- a/src/Makefile.am	2014-01-25 23:48:24.000000000 +0100
+++ b/src/Makefile.am	2014-12-08 21:11:50.586778992 +0100
@@ -7,6 +7,7 @@
 	 -g
 
 bin_PROGRAMS = boblightd \
+	boblight-aml \
 	boblight-constant
         
 
@@ -19,6 +20,11 @@
 
 endif
 
+boblight_aml_SOURCES  = clients/boblight-aml/boblight-aml.cpp
+boblight_aml_SOURCES += clients/boblight-aml/flagmanager-aml.cpp
+boblight_aml_SOURCES += clients/flagmanager.cpp
+boblight_aml_SOURCES += util/misc.cpp
+
 boblight_v4l_SOURCES = \
 	clients/boblight-v4l/boblight-v4l.cpp \
 	clients/boblight-v4l/flagmanager-v4l.cpp \
diff -urPp src/clients/boblight-aml.cpp src/clients/boblight-aml/boblight-aml.cpp
--- a/src/clients/boblight-aml.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/clients/boblight-aml/boblight-aml.cpp	2015-01-13 19:37:19.106281981 +0100
@@ -0,0 +1,332 @@
+/*
+ * boblight
+ * Copyright (C) Bob  2009 
+ * 
+ * boblight is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * boblight is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define BOBLIGHT_DLOPEN
+#include "lib/boblight.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <signal.h>
+
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+
+#include "config.h"
+#include "util/misc.h"
+#include "util/timeutils.h"
+#include "flagmanager-aml.h"
+
+using namespace std;
+
+//#include <linux/pivos/aml_snapshot.h>
+
+//from linux/amlogic/amports/amvideocap.h
+#define AMVIDEOCAP_IOC_MAGIC 'V'
+#define AMVIDEOCAP_IOW_SET_WANTFRAME_WIDTH      _IOW(AMVIDEOCAP_IOC_MAGIC, 0x02, int)
+#define AMVIDEOCAP_IOW_SET_WANTFRAME_HEIGHT     _IOW(AMVIDEOCAP_IOC_MAGIC, 0x03, int)
+
+
+struct aml_snapshot_t {
+  unsigned int  dst_width;
+  unsigned int  dst_height;
+  unsigned int  dst_stride;
+  unsigned int  dst_size;
+  void         *dst_vaddr;
+};
+
+volatile bool g_stop = false;
+CFlagManagerAML g_flagmanager;
+/*********************************************************
+ *********************************************************/
+static void SignalHandler(int signum)
+{
+  if (signum == SIGTERM)
+  {
+    fprintf(stderr, "caught SIGTERM\n");
+    g_stop = true;
+  }
+  else if (signum == SIGINT)
+  {
+    fprintf(stderr, "caught SIGTERM\n");
+    g_stop = true;
+  }
+}
+
+#define VIDEO_PATH       "/dev/amvideo"
+#define AMSTREAM_IOC_MAGIC  'S'
+#define AMSTREAM_IOC_GET_VIDEO_DISABLE  _IOR(AMSTREAM_IOC_MAGIC, 0x48, unsigned long)
+static int amvideo_utils_video_playing()
+{
+  int video_fd;
+  int video_disable;
+
+  video_fd = open(VIDEO_PATH, O_RDWR);
+  if (video_fd < 0) {
+    return -1;
+  }
+
+  ioctl(video_fd, AMSTREAM_IOC_GET_VIDEO_DISABLE, &video_disable);
+  if (video_disable)
+  {
+    close(video_fd);
+    return 1;
+  }
+
+  close(video_fd);
+
+//  fprintf(stderr, "pos x %d y %d w %d h %d\n",snapshot.src_x, snapshot.src_y,snapshot.src_width,snapshot.src_height);
+  return 0;
+}
+
+static int capture_frame(int fd, aml_snapshot_t &snapshot)
+{
+  int ret = 0;
+  
+  ssize_t readResult = pread(fd, snapshot.dst_vaddr, snapshot.dst_size, 0);
+
+  if (readResult < snapshot.dst_size)
+  {
+    fprintf(stderr, "frame read returned %d\n", readResult);
+  }
+  //fprintf(stderr, "requ: %d read %d \n", snapshot.dst_size, readResult);
+  fprintf(stderr, ".");
+  return ret;
+}
+
+static int configure_capture(int fd, aml_snapshot_t &snapshot)
+{
+  int ret = 0;
+  int ioctlret = 0;
+
+  if ((ioctlret = ioctl(fd, AMVIDEOCAP_IOW_SET_WANTFRAME_WIDTH, snapshot.dst_width)) != 0)
+  {
+    ret = 2;
+    fprintf(stderr, "Error setting frame width (ret: %d errno: %d)\n", ioctlret, errno);
+  }
+    
+  
+  if ((ioctlret = ioctl(fd, AMVIDEOCAP_IOW_SET_WANTFRAME_HEIGHT, snapshot.dst_height)) != 0)
+  {
+    ret = 3;
+    fprintf(stderr, "Error setting frame height (ret: %d errno: %d)\n", ioctlret, errno);
+  }
+
+  return ret;
+}
+
+static void frameToboblight(void *boblight, uint8_t* outputptr, int w, int h, int stride)
+{
+  if (!boblight)
+  {
+    fprintf(stderr, "no boblight\n");
+    return;
+  }
+  if (!outputptr)
+  {
+    fprintf(stderr, "no outputptr\n");
+    return;
+  }
+  //read out pixels and hand them to libboblight
+  uint8_t* buffptr;
+  for (int y = h; y > 0; y--) {
+    buffptr = outputptr + stride * y;
+    for (int x = 0; x < w; x++) {
+      int rgb[3];
+      rgb[2] = *(buffptr++);
+      rgb[1] = *(buffptr++);
+      rgb[0] = *(buffptr++);
+
+      //fprintf(stdout, "frameToboblight: x(%d), y(%d)\n", x, y);
+
+      boblight_addpixelxy(boblight, x, y, rgb);
+    }
+  }
+}
+
+static int Run(void* boblight)
+{
+  int snapshot_fd = -1;               
+  aml_snapshot_t aml_snapshot = {0};
+  int lastPriority = 255;
+
+  aml_snapshot.dst_width  = 160;
+  aml_snapshot.dst_height = 160;
+
+  // calc stride, size and alloc mem
+  aml_snapshot.dst_stride = aml_snapshot.dst_width  * 3;
+  aml_snapshot.dst_size   = aml_snapshot.dst_stride * aml_snapshot.dst_height;
+  aml_snapshot.dst_vaddr  = calloc(aml_snapshot.dst_size, 1);
+
+  fprintf(stdout, "Connection to boblightd config: width(%d), height(%d)\n",
+    aml_snapshot.dst_width, aml_snapshot.dst_height);
+  //tell libboblight how big our image is
+  boblight_setscanrange(boblight, (int)aml_snapshot.dst_width, (int)aml_snapshot.dst_height);
+
+  while(!g_stop)
+  {
+    int64_t bgn = GetTimeUs();
+
+    if (snapshot_fd == -1) {
+      snapshot_fd = open(g_flagmanager.m_device.c_str(), O_RDWR, 0);
+
+      if (snapshot_fd == -1) {
+        sleep(1);
+        continue;
+      } else {
+        fprintf(stdout, "snapshot_fd(%d) \n", snapshot_fd);
+      }
+    }
+
+    // match source ratio if possible
+    if (amvideo_utils_video_playing() != 0) {
+      if ( lastPriority != 255)
+      {
+        boblight_setpriority(boblight, 255);
+        lastPriority = 255;
+      }
+      sleep(1);
+      continue;
+    }
+
+    if (configure_capture(snapshot_fd, aml_snapshot) == 0)
+    {
+      if (capture_frame(snapshot_fd, aml_snapshot) == 0)
+      {
+        // image to boblight convert.
+        frameToboblight(boblight, (uint8_t*)aml_snapshot.dst_vaddr,
+        aml_snapshot.dst_width, aml_snapshot.dst_height, aml_snapshot.dst_stride);
+  
+        if (lastPriority != g_flagmanager.m_priority)
+        {
+          boblight_setpriority(boblight, g_flagmanager.m_priority);
+          lastPriority = g_flagmanager.m_priority;
+        }
+        if (!boblight_sendrgb(boblight, 1, NULL))
+        {
+          // some error happened, probably connection broken, so bitch and try again
+          PrintError(boblight_geterror(boblight));
+          boblight_destroy(boblight);
+          continue;
+        }
+      }
+      else
+      {
+        fprintf(stdout, "nap time\n");
+        sleep(1);
+      }
+    }
+    int64_t end = GetTimeUs();
+    float calc_time_ms = (float)(end - bgn) / 1000.0;
+    // throttle to 100ms max cycle rate
+    calc_time_ms -= 100.0;
+    if ((int)calc_time_ms < 0)
+      usleep((int)(-calc_time_ms * 1000));
+  }
+
+  // last image is black
+  boblight_setpriority(boblight, 255);
+  boblight_destroy(boblight);
+  close(snapshot_fd);
+  return 0;
+}
+
+/*********************************************************
+ *********************************************************/
+int main(int argc, char *argv[])
+{
+  //load the boblight lib, if it fails we get a char* from dlerror()
+  const char* boblight_error = boblight_loadlibrary(NULL);
+  if (boblight_error)
+  {
+    PrintError(boblight_error);
+    return 1;
+  }
+
+  //try to parse the flags and bitch to stderr if there's an error
+  try {
+    g_flagmanager.ParseFlags(argc, argv);
+  }
+  catch (string error) {
+    PrintError(error);
+    g_flagmanager.PrintHelpMessage();
+    return 1;
+  }
+  
+  if (g_flagmanager.m_printhelp) {
+    g_flagmanager.PrintHelpMessage();
+    return 1;
+  }
+
+  if (g_flagmanager.m_printboblightoptions) {
+    g_flagmanager.PrintBoblightOptions();
+    return 1;
+  }
+
+
+  fprintf(stderr, "Using device: %s \n", g_flagmanager.m_device.c_str());
+
+  //set up signal handlers
+  signal(SIGINT,  SignalHandler);
+  signal(SIGTERM, SignalHandler);
+
+  //keep running until we want to quit
+  while(!g_stop) {
+    //init boblight
+    void* boblight = boblight_init();
+
+    fprintf(stdout, "Connecting to boblightd(%p)\n", boblight);
+    
+    //try to connect, if we can't then bitch to stderr and destroy boblight
+    if (!boblight_connect(boblight, g_flagmanager.m_address, g_flagmanager.m_port, 5000000) ||
+        !boblight_setpriority(boblight, 255)) {
+      PrintError(boblight_geterror(boblight));
+      fprintf(stdout, "Waiting 10 seconds before trying again\n");
+      boblight_destroy(boblight);
+      sleep(10);
+      continue;
+    }
+
+    fprintf(stdout, "Connection to boblightd opened\n");
+
+    //try to parse the boblight flags and bitch to stderr if we can't
+    try {
+      g_flagmanager.ParseBoblightOptions(boblight);
+    }
+    catch (string error) {
+      PrintError(error);
+      return 1;
+    }
+
+    try {
+      Run(boblight);
+    }
+    catch (string error) {
+      PrintError(error);
+      boblight_destroy(boblight);
+      return 1;
+    }
+  }
+  fprintf(stdout, "Exiting\n");
+}
diff -urPp src/clients/flagmanager-aml.cpp src/clients/boblight-aml/flagmanager-aml.cpp
--- a/src/clients/flagmanager-aml.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/clients/boblight-aml/flagmanager-aml.cpp	2015-01-13 19:39:15.719366507 +0100
@@ -0,0 +1,60 @@
+/*
+ * boblight
+ * Copyright (C) Bob  2009 
+ * 
+ * boblight is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * boblight is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <iostream>
+
+#include "flagmanager-aml.h"
+#include "util/misc.h"
+#include "config.h"
+
+#define DEFAULT_CAPTURE_DEVICE "/dev/amvideocap0"
+
+using namespace std;
+
+CFlagManagerAML::CFlagManagerAML()
+{
+  // extend the flags -d -> device
+  m_flags += "d:";
+  m_device = DEFAULT_CAPTURE_DEVICE;
+}
+
+void CFlagManagerAML::ParseFlagsExtended(int& argc, char**& argv, int& c, char*& optarg)
+{
+  if (c == 'd') //devicename
+  {
+    if (optarg) //optional device
+    {
+      m_device = optarg;
+    }
+  }
+}
+
+void CFlagManagerAML::PrintHelpMessage()
+{
+  cout << "Usage: boblight-aml\n";
+  cout << "\n";
+  cout << "  options:\n";
+  cout << "\n";
+  cout << "  -p  priority, from 0 to 255, default is 128\n";
+  cout << "  -s  address[:port], set the address and optional port to connect to\n";
+  cout << "  -o  add libboblight option, syntax: [light:]option=value\n";
+  cout << "  -l  list libboblight options\n";
+  cout << "  -f  fork\n";
+  cout << "  -d  <device> (defaults to " << m_device << ")\n";
+  cout << "\n";
+}
diff -urPp src/clients/flagmanager-aml.h src/clients/boblight-aml/flagmanager-aml.h
--- a/src/clients/flagmanager-aml.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/clients/boblight-aml/flagmanager-aml.h	2015-01-13 19:36:31.567611323 +0100
@@ -0,0 +1,35 @@
+/*
+ * boblight
+ * Copyright (C) Bob  2009 
+ * 
+ * boblight is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * boblight is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FLAGMANAGERAML
+#define FLAGMANAGERAML
+
+#include "clients/flagmanager.h"
+
+class CFlagManagerAML : public CFlagManager
+{
+  public:
+    CFlagManagerAML();
+    void ParseFlagsExtended(int& argc, char**& argv, int& c, char*& optarg);
+
+    void PrintHelpMessage();
+    std::string m_device;           //device to open for amvideocap
+
+};
+
+#endif //FLAGMANAGERAML
\ Kein Zeilenumbruch am Dateiende.
