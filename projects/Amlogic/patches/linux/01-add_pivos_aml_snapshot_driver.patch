--- a/drivers/amlogic/Kconfig.orig	2014-12-06 01:09:57.807301205 +0100
+++ b/drivers/amlogic/Kconfig	2014-12-06 01:10:46.703299272 +0100
@@ -94,4 +94,10 @@
 source "drivers/amlogic/pmu/Kconfig"
 source "drivers/amlogic/touch/Kconfig"
 source "drivers/amlogic/cpufreq/Kconfig"
+
+#
+#pivos aml snapshot
+#
+source "drivers/amlogic/pivos_amsnapshot/Kconfig"
+
 endmenu
--- a/drivers/amlogic/pivos_amsnapshot.old/aml_snapshot.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/pivos_amsnapshot/aml_snapshot.c	2014-12-06 01:14:57.675289346 +0100
@@ -0,0 +1,683 @@
+/*
+ * drivers/amlogic/pivos/aml_snapshot.c
+ *
+ * video scaler for thumbnails/snapshots
+ * CONFIG_PIVOS_AM_SNAPSHOT
+ *
+ * Copyright (C) 2013 PivosGroup
+ *
+ * Written by Scott Davilla <scott.davilla@pivosgroup.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD Licence or GNU General Public License
+ * as published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+
+#include <asm/uaccess.h>
+
+#include <linux/pivos/aml_snapshot.h>
+
+#if 1
+  #define DPRINT(...) printk(KERN_INFO __VA_ARGS__)
+  #define DTRACE()    DPRINT(KERN_INFO "%s()\n", __FUNCTION__)
+#else
+  #define DPRINT(...)
+  #define DTRACE()
+#endif
+#define   DERROR(...) printk(KERN_ERR __VA_ARGS__)
+
+#define SNAPSHOT_DRIVER_NAME "aml_snapshot"
+#define SNAPSHOT_DEFAULT_WIDTH  (1280 / 2)
+#define SNAPSHOT_DEFAULT_HEIGHT (720  / 2)
+#define SNAPSHOT_DEFAULT_FORMAT AMSNAPSHOT_FMT_S24_RGB
+
+#define CANVAS_ALIGNED(x)	(((x) + 7) & ~7)
+
+
+struct aml_internal_snapshot_t {
+  // temp frame for optimizing kernel to userland
+  // copy of scaled snapshot.
+  int                   frame_size;
+  int                   frame_width;
+  int                   frame_height;
+  int                   frame_stride;
+  void                 *frame_vaddr;
+
+  // canvas details.
+  // canvas_format is GE2D_FORMAT__XXX
+  int                   canvas_id;
+  int                   canvas_width;
+  int                   canvas_height;
+  int                   canvas_stride;
+  unsigned int          canvas_format;
+  unsigned int          canvas_psize;
+  unsigned long         canvas_paddr;
+  void                 *canvas_vaddr;
+  ge2d_context_t       *ge2d_context;
+
+  // user snapshot info mirror.
+  // dst_format is AMSNAPSHOT_FMT_XXX
+  struct aml_snapshot_t user_snapshot;
+
+  // device config
+  int                   config_major;
+  struct device        *config_device;
+};
+
+static struct aml_internal_snapshot_t *g_snapshot;
+
+/*********************************************************
+ *********************************************************/
+static size_t GE2D_FORMAT_to_size(unsigned int format)
+{
+  switch (format & GE2D_BPP_MASK) {
+    case GE2D_BPP_8BIT:
+      return 1;
+    case GE2D_BPP_16BIT:
+      return 2;
+    case GE2D_BPP_24BIT:
+      return 3;
+    case GE2D_BPP_32BIT:
+    default:
+      return 4;
+  }
+}
+
+static int VIDTYPE_to_GE2D_FORMAT(vframe_t* vf)
+{
+  int format = GE2D_FORMAT_M24_YUV420;
+
+  if (vf->type & VIDTYPE_VIU_422) {
+    //DPRINT("GE2D_FORMAT_S16_YUV422.\n");
+    format = GE2D_FORMAT_S16_YUV422;
+    if (vf->type & VIDTYPE_INTERLACE_BOTTOM)
+      format |= GE2D_FORMAT_S16_YUV422B & (3<<3);
+    else if(vf->type & VIDTYPE_INTERLACE_TOP)
+      format |= GE2D_FORMAT_S16_YUV422T & (3<<3);
+
+  } else if (vf->type & VIDTYPE_VIU_444) {
+    //DPRINT("GE2D_FORMAT_S24_YUV444.\n");
+    format = GE2D_FORMAT_S24_YUV444;
+    if (vf->type & VIDTYPE_INTERLACE_BOTTOM)
+      format |= GE2D_FORMAT_S24_YUV444B & (3<<3);
+    else if (vf->type & VIDTYPE_INTERLACE_TOP)
+      format |= GE2D_FORMAT_S24_YUV444T & (3<<3);
+
+  } else if (vf->type & VIDTYPE_VIU_NV21) {
+    //DPRINT("GE2D_FORMAT_M24_NV21.\n");
+    format = GE2D_FORMAT_M24_NV21;
+    if (vf->type & VIDTYPE_INTERLACE_BOTTOM)
+      format |= GE2D_FORMAT_M24_NV21B   & (3<<3);
+    else if (vf->type & VIDTYPE_INTERLACE_TOP)
+      format |= GE2D_FORMAT_M24_NV21T   & (3<<3);
+
+  } else {
+    //DPRINT("GE2D_FORMAT_M24_YUV420.\n");
+    format = GE2D_FORMAT_M24_YUV420;
+    if (vf->type & VIDTYPE_INTERLACE_BOTTOM)
+      format |= GE2D_FORMAT_M24_YUV420B & (3<<3);
+    else if (vf->type & VIDTYPE_INTERLACE_TOP)
+      format |= GE2D_FORMAT_M24_YUV420T & (3<<3);
+  }
+
+  return format;
+}
+
+static unsigned int AMSNAPSHOT_FMT_to_GE2D_FORMAT(int format)
+{
+  unsigned int ge2d_format;
+  switch(format) {
+  case AMSNAPSHOT_FMT_S24_BGR:
+    ge2d_format = GE2D_FORMAT_S24_RGB;
+    break;
+  case AMSNAPSHOT_FMT_S24_RGB:
+    ge2d_format = GE2D_FORMAT_S24_BGR;
+    break;
+  case AMSNAPSHOT_FMT_S32_RGBA:
+    ge2d_format = GE2D_FORMAT_S32_RGBA;
+    break;
+  case AMSNAPSHOT_FMT_S32_BGRA:
+    ge2d_format = GE2D_FORMAT_S32_BGRA;
+    break;
+  case AMSNAPSHOT_FMT_S32_ABGR:
+    ge2d_format = GE2D_FORMAT_S32_ABGR;
+    break;
+  default:
+  case AMSNAPSHOT_FMT_S32_ARGB:
+    ge2d_format = GE2D_FORMAT_S32_ARGB;
+    break;
+  }
+
+  return ge2d_format;
+}
+
+static int GE2D_FORMAT_to_AMSNAPSHOT_FMT(unsigned int format)
+{
+  int aml_snapshot_format;
+  switch(format) {
+  case GE2D_FORMAT_S24_RGB:
+    aml_snapshot_format = AMSNAPSHOT_FMT_S24_BGR;
+    break;
+  case GE2D_FORMAT_S24_BGR:
+    aml_snapshot_format = AMSNAPSHOT_FMT_S24_RGB;
+    break;
+  case GE2D_FORMAT_S32_RGBA:
+    aml_snapshot_format = AMSNAPSHOT_FMT_S32_RGBA;
+    break;
+  case GE2D_FORMAT_S32_BGRA:
+    aml_snapshot_format = AMSNAPSHOT_FMT_S32_BGRA;
+    break;
+  case GE2D_FORMAT_S32_ABGR:
+    aml_snapshot_format = AMSNAPSHOT_FMT_S32_ABGR;
+    break;
+  default:
+  case GE2D_FORMAT_S32_ARGB:
+    aml_snapshot_format = AMSNAPSHOT_FMT_S32_ARGB;
+    break;
+  }
+
+  return aml_snapshot_format;
+}
+
+/*********************************************************
+ *********************************************************/
+static ssize_t frame_type_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+  vframe_t *cur_dispbuf = get_cur_dispbuf();
+
+  if (cur_dispbuf) {
+    if ((cur_dispbuf->type & VIDTYPE_VIU_422) == VIDTYPE_VIU_422)
+      return sprintf(buf, "VIDTYPE_VIU_422\n");
+    else if ((cur_dispbuf->type & VIDTYPE_VIU_444) == VIDTYPE_VIU_444)
+      return sprintf(buf, "VIDTYPE_VIU_444\n");
+#ifdef MESON_CPU_TYPE
+    else if((cur_dispbuf->type & VIDTYPE_VIU_NV21) == VIDTYPE_VIU_NV21)
+      return sprintf(buf, "VIDTYPE_VIU_NV21\n");
+#endif
+    else
+      return sprintf(buf, "VIDTYPE_VIU_??? = (%d)\n", cur_dispbuf->type);
+  }
+
+  return sprintf(buf, "NA\n");
+}
+
+static ssize_t frame_addr_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+  vframe_t *cur_dispbuf = get_cur_dispbuf();
+
+  if (cur_dispbuf) {
+    u32 addr[3];
+    canvas_t canvas;
+
+    canvas_read(cur_dispbuf->canvas0Addr & 0xff, &canvas);
+    addr[0] = canvas.addr;
+    canvas_read((cur_dispbuf->canvas0Addr >> 8) & 0xff, &canvas);
+    addr[1] = canvas.addr;
+    canvas_read((cur_dispbuf->canvas0Addr >> 16) & 0xff, &canvas);
+    addr[2] = canvas.addr;
+
+    return sprintf(buf, "0x%x-0x%x-0x%x\n", addr[0], addr[1], addr[2]);
+  }
+  return sprintf(buf, "NA\n");
+}
+
+static ssize_t frame_width_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+  vframe_t *cur_dispbuf = get_cur_dispbuf();
+
+  if (cur_dispbuf)
+    return sprintf(buf, "%d\n", cur_dispbuf->width);
+
+  return sprintf(buf, "NA\n");
+}
+
+static ssize_t frame_height_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+  vframe_t *cur_dispbuf = get_cur_dispbuf();
+
+  if (cur_dispbuf)
+    return sprintf(buf, "%d\n", cur_dispbuf->height);
+
+  return sprintf(buf, "NA\n");
+}
+
+/*********************************************************
+ *********************************************************/
+static int aml_snapshot_snap(void)
+{
+  vframe_t *vf = get_cur_dispbuf();
+
+  if (vf) {
+    canvas_t canvas;
+    vframe_t vf_local = *vf;
+    config_para_ex_t ge2d_config;
+    struct aml_snapshot_t user_snapshot = g_snapshot->user_snapshot;
+    // check for special 'zero'flags
+    if (user_snapshot.src_width  == 0)
+      user_snapshot.src_width  = vf_local.width;
+    if (user_snapshot.src_height == 0)
+      user_snapshot.src_height = vf_local.height;
+    if (user_snapshot.dst_width  == 0)
+      user_snapshot.dst_width  = g_snapshot->canvas_width;
+    if (user_snapshot.dst_height == 0)
+      user_snapshot.dst_height = g_snapshot->canvas_height;
+
+    // setup ge2d_config
+    memset(&ge2d_config, 0x00, sizeof(config_para_ex_t));
+    ge2d_config.alu_const_color = 0; //0x000000ff;
+    ge2d_config.src1_gb_alpha   = 0; //0xff;
+    // src, handle all planes as the src format can change
+    canvas_read( vf_local.canvas0Addr & 0xff, &canvas);
+    ge2d_config.src_planes[0].addr    = canvas.addr;
+    ge2d_config.src_planes[0].w       = canvas.width;
+    ge2d_config.src_planes[0].h       = canvas.height;
+    canvas_read((vf_local.canvas0Addr >>8) & 0xff, &canvas);
+    ge2d_config.src_planes[1].addr    = canvas.addr;
+    ge2d_config.src_planes[1].w       = canvas.width;
+    ge2d_config.src_planes[1].h       = canvas.height;
+    canvas_read((vf_local.canvas0Addr >> 16) & 0xff, &canvas);
+    ge2d_config.src_planes[2].addr    = canvas.addr;
+    ge2d_config.src_planes[2].w       = canvas.width;
+    ge2d_config.src_planes[2].h       = canvas.height;
+    //
+    ge2d_config.src_para.canvas_index = vf_local.canvas0Addr;
+    ge2d_config.src_para.mem_type     = CANVAS_TYPE_INVALID;
+    ge2d_config.src_para.format       = VIDTYPE_to_GE2D_FORMAT(vf);
+    ge2d_config.src_para.top          = 0;
+    ge2d_config.src_para.left         = 0;
+    ge2d_config.src_para.width        = vf_local.width;
+    ge2d_config.src_para.height       = vf_local.height;
+    ge2d_config.src_para.color        = 0xffffffff;
+    ge2d_config.src2_para.mem_type    = CANVAS_TYPE_INVALID;
+
+    // dst (always rgb+a) so only one plane
+    canvas_read(g_snapshot->canvas_id & 0xff, &canvas);
+    ge2d_config.dst_planes[0].addr    = canvas.addr;
+    ge2d_config.dst_planes[0].w       = canvas.width;
+    ge2d_config.dst_planes[0].h       = canvas.height;
+    //
+    ge2d_config.dst_para.canvas_index = g_snapshot->canvas_id;
+    ge2d_config.dst_para.mem_type     = CANVAS_TYPE_INVALID;
+    ge2d_config.dst_para.format       = g_snapshot->canvas_format;
+    ge2d_config.dst_para.top          = 0;
+    ge2d_config.dst_para.left         = 0;
+    ge2d_config.dst_para.width        = g_snapshot->canvas_width;
+    ge2d_config.dst_para.height       = g_snapshot->canvas_width;
+    ge2d_config.dst_para.color        = 0;
+
+    if (ge2d_context_config_ex(g_snapshot->ge2d_context, &ge2d_config) == 0) {
+      // stretch to fit
+      stretchblt_noalpha(g_snapshot->ge2d_context,
+        user_snapshot.src_x, user_snapshot.src_y,
+        user_snapshot.src_width, user_snapshot.src_height,
+        0, 0, user_snapshot.dst_width, user_snapshot.dst_height);
+
+    } else {
+      DERROR("ge2d_context_config error.\n");
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+/*********************************************************
+ * /dev/aml_snapshot APIs
+ *********************************************************/
+static int aml_snapshot_open(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int aml_snapshot_release(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static long aml_snapshot_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+  switch (cmd) {
+  case AMSNAPSHOT_IOC_GET_FRAME:
+    {
+      struct aml_snapshot_t *user_snapshot = (struct aml_snapshot_t*)arg;
+
+      // sanity check user settings. ge2d stalls if width is too small
+      if (user_snapshot->dst_width  > g_snapshot->canvas_width)
+        return -EINVAL;
+      if (user_snapshot->dst_height > g_snapshot->canvas_height)
+        return -EINVAL;
+      //if (user_snapshot->dst_width  < 160)
+      //  return -EINVAL;
+      //if (user_snapshot->dst_height < 80)
+      //  return -EINVAL;
+
+      // update interal settings from user settings.
+      g_snapshot->user_snapshot = *user_snapshot;
+      // paranoia, dst_vaddr is not valid internally,
+      g_snapshot->user_snapshot.dst_vaddr = 0;
+
+      if (aml_snapshot_snap() == 0)
+      {
+        char *dst, *src = (char*)g_snapshot->canvas_vaddr;
+
+        if ((user_snapshot->dst_height == g_snapshot->canvas_height) &&
+            (user_snapshot->dst_stride == g_snapshot->canvas_stride)) {
+
+          // user height/stride matches canvas height/stride
+          int size = user_snapshot->dst_stride * user_snapshot->dst_height;
+          dst = (char*)user_snapshot->dst_vaddr;
+          if (copy_to_user(dst, src, size) != 0)
+              return -EFAULT;
+        }
+        else
+        {
+          // sub-regioned, need to copy out line-by-line.
+          int i, dst_stride, canvas_stride;
+
+          // update temp frame info and realloc if needed.
+          if ((user_snapshot->dst_size != g_snapshot->frame_size) ||
+              (g_snapshot->frame_vaddr == NULL)) {
+            g_snapshot->frame_width  = user_snapshot->dst_width;
+            g_snapshot->frame_height = user_snapshot->dst_height;
+            g_snapshot->frame_stride = user_snapshot->dst_stride;
+            g_snapshot->frame_size   = user_snapshot->dst_size;
+            if (g_snapshot->frame_vaddr)
+              kfree(g_snapshot->frame_vaddr);
+            g_snapshot->frame_vaddr = kmalloc(g_snapshot->frame_size, GFP_KERNEL);
+          }
+
+          // copy line by line into temp frame.
+          // required as if we are sub-region,
+          // canvas stride != dst stride.
+          dst =    (char*)g_snapshot->frame_vaddr;
+          dst_stride    = g_snapshot->frame_stride;
+          canvas_stride = g_snapshot->canvas_stride;
+          for (i = 0; i < g_snapshot->frame_height; i++) {
+            memcpy(dst, src, dst_stride);
+            dst += dst_stride;
+            src += canvas_stride;
+          }
+          // copy temp frame to userland in one chunk,
+          // instead of line-by-line.
+          src = g_snapshot->frame_vaddr;
+          dst = (char*)user_snapshot->dst_vaddr;
+          if (copy_to_user(dst, src, user_snapshot->dst_size) != 0)
+              return -EFAULT;
+        }
+      }
+      else
+      {
+        return -EINVAL;
+      }
+
+    }
+    break;
+
+    default:
+      return -EINVAL;
+  }
+
+  return 0;
+}
+
+static int aml_snapshot_mmap(struct file *file, struct vm_area_struct *vma)
+{
+  unsigned long off;
+  unsigned vm_size = vma->vm_end - vma->vm_start;
+
+  if (vm_size == 0)
+    return -EAGAIN;
+
+  // convert from pfn (page frame number) to physical address
+  off = vma->vm_pgoff << PAGE_SHIFT;
+  // add the canvas physical address
+  off += g_snapshot->canvas_paddr;
+  // convert physical address back to pfn
+  off = off >> PAGE_SHIFT;
+
+  vma->vm_flags |= VM_RESERVED | VM_IO;
+
+  if (remap_pfn_range(vma, vma->vm_start, off,
+    vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+
+    DERROR("aml_snapshot failed remap_pfn_range\n");
+    return -EAGAIN;
+  }
+
+  return 0;
+}
+
+static void aml_snapshot_init(struct resource *iomem)
+{
+  // canvas setup
+  g_snapshot->canvas_paddr  = iomem->start;
+  g_snapshot->canvas_psize  = iomem->end - iomem->start + 1;
+  //g_snapshot->canvas_vaddr  = ioremap_wc(g_snapshot->canvas_paddr, g_snapshot->canvas_psize);
+  g_snapshot->canvas_vaddr  = ioremap_nocache(g_snapshot->canvas_paddr, g_snapshot->canvas_psize);
+  g_snapshot->canvas_format = AMSNAPSHOT_FMT_to_GE2D_FORMAT(SNAPSHOT_DEFAULT_FORMAT);
+  g_snapshot->canvas_width  = SNAPSHOT_DEFAULT_WIDTH;
+  g_snapshot->canvas_height = SNAPSHOT_DEFAULT_HEIGHT;
+  g_snapshot->canvas_stride = g_snapshot->canvas_width;
+  g_snapshot->canvas_stride*= GE2D_FORMAT_to_size(g_snapshot->canvas_format);
+
+  // we do not have an 'assigned' canvas index,
+  // borrow one that looks unassigned.
+  g_snapshot->canvas_id = ALLOC_CANVAS_INDEX - 1;
+  canvas_config(g_snapshot->canvas_id,
+    g_snapshot->canvas_paddr,
+    g_snapshot->canvas_width * GE2D_FORMAT_to_size(g_snapshot->canvas_format),
+    g_snapshot->canvas_height,
+    CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+
+  // default src/dst bounds for snapshot
+  g_snapshot->user_snapshot.src_x      = 0;
+  g_snapshot->user_snapshot.src_y      = 0;
+  g_snapshot->user_snapshot.src_width  = 0; // implies vf_local.width
+  g_snapshot->user_snapshot.src_height = 0; // implies vf_local.height
+  g_snapshot->user_snapshot.dst_width  = 0; // implies g_snapshot->canvas_width
+  g_snapshot->user_snapshot.dst_height = 0; // implies g_snapshot->canvas_height
+  // helper vars for copy back to userland
+  g_snapshot->user_snapshot.dst_stride = g_snapshot->user_snapshot.dst_width;
+  g_snapshot->user_snapshot.dst_stride*= GE2D_FORMAT_to_size(g_snapshot->canvas_format);
+  g_snapshot->user_snapshot.dst_format = GE2D_FORMAT_to_AMSNAPSHOT_FMT(g_snapshot->canvas_format);
+  g_snapshot->user_snapshot.dst_vaddr  = 0;
+}
+
+/*********************************************************
+ *********************************************************/
+static struct class_attribute aml_snapshot_class_attrs[] = {
+  __ATTR_RO(frame_type),
+  __ATTR_RO(frame_addr),
+  __ATTR_RO(frame_width),
+  __ATTR_RO(frame_height),
+  __ATTR_NULL
+};
+
+static struct class aml_snapshot_class = {
+  .name           = SNAPSHOT_DRIVER_NAME,
+  .class_attrs    = aml_snapshot_class_attrs,
+};
+
+const static struct file_operations aml_snapshot_fops = {
+  .owner          = THIS_MODULE,
+  .open           = aml_snapshot_open,
+  .release        = aml_snapshot_release,
+  .unlocked_ioctl = aml_snapshot_ioctl,
+  .mmap           = aml_snapshot_mmap,
+};
+
+static int aml_snapshot_probe(struct platform_device *pdev)
+{
+  int rtn = 0;
+  struct resource *iomem;
+
+  g_snapshot = kzalloc(sizeof(struct aml_internal_snapshot_t), GFP_KERNEL);
+  if (!g_snapshot) {
+    DERROR("Cannot kzalloc for aml_snapshot device\n");
+    rtn = -ENOMEM;
+    goto err1;
+  }
+  memset(g_snapshot, 0x00, sizeof(struct aml_internal_snapshot_t));
+
+  iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  if (!iomem)
+  {
+    DERROR("aml_snapshot memory resource undefined.\n");
+    rtn = -ENOMEM;
+    goto err1;
+  }
+  aml_snapshot_init(iomem);
+
+  rtn = register_chrdev(0, SNAPSHOT_DRIVER_NAME, &aml_snapshot_fops);
+  if (rtn <= 0) {
+    DERROR("Cannot register major for aml_snapshot device\n");
+    goto err2;
+  }
+
+  g_snapshot->config_major = rtn;
+  DPRINT("aml_snapshot config major:%d\n", rtn);
+  rtn = class_register(&aml_snapshot_class);
+  if (rtn) {
+    DPRINT(" failed to class register aml_snapshot_class\n");
+    goto err3;
+  }
+
+  g_snapshot->config_device = device_create(&aml_snapshot_class, NULL,
+    MKDEV(g_snapshot->config_major, 0), NULL, SNAPSHOT_DRIVER_NAME);
+
+  if (IS_ERR(g_snapshot->config_device)) {
+    DERROR("Cannot create aml_snapshot device\n");
+    goto err4;
+  }
+
+  g_snapshot->ge2d_context = create_ge2d_work_queue();
+
+  return 0;
+
+err4:
+  class_unregister(&aml_snapshot_class);
+err3:
+  unregister_chrdev(g_snapshot->config_major, SNAPSHOT_DRIVER_NAME);
+err2:
+  kfree(g_snapshot), g_snapshot = NULL;
+err1:
+  return rtn;
+}
+
+static int aml_snapshot_remove(struct platform_device *pdev)
+{
+  if (g_snapshot->config_device) {
+  //device_unregister(g_snapshot->config_device);
+    device_destroy(&aml_snapshot_class, MKDEV(g_snapshot->config_major, 0));
+    g_snapshot->config_device = NULL;
+  }
+  class_unregister(&aml_snapshot_class);
+  class_destroy(&aml_snapshot_class);
+	unregister_chrdev(g_snapshot->config_major, SNAPSHOT_DRIVER_NAME);
+
+  destroy_ge2d_work_queue(g_snapshot->ge2d_context);
+  if (g_snapshot->frame_vaddr)
+    kfree(g_snapshot->frame_vaddr);
+  if (g_snapshot->canvas_vaddr)
+    iounmap(g_snapshot->canvas_vaddr);
+  kfree(g_snapshot), g_snapshot = NULL;
+
+  return 0;
+}
+
+/*********************************************************
+ *********************************************************/
+static struct platform_driver aml_snapshot_driver = {
+  .probe          = aml_snapshot_probe,
+  .remove         = aml_snapshot_remove,
+  .suspend        = NULL,
+  .resume         = NULL,
+  .driver         = {
+    .owner        = THIS_MODULE,
+    .name         = SNAPSHOT_DRIVER_NAME,
+  },
+};
+
+static int __init aml_snapshot_module_init(void)
+{
+  if (platform_driver_register(&aml_snapshot_driver)) {
+    DPRINT("failed to register aml_snapshot module\n");
+  return -ENODEV;
+  }
+
+  return 0;
+}
+
+static void __exit aml_snapshot_module_exit(void)
+{
+  platform_driver_unregister(&aml_snapshot_driver);
+}
+
+module_init(aml_snapshot_module_init);
+module_exit(aml_snapshot_module_exit);
+
+MODULE_AUTHOR("scott.davilla@pivosgroup.com>");
+MODULE_DESCRIPTION("Pivos AMLogic Video SnapShot");
+MODULE_LICENSE("GPL");
+
+/*
+cd /cache/recovery/test/
+cp /storage/external_storage/sdcard1/test /cache/recovery/test/
+cp /storage/external_storage/sdcard1/test2 /cache/recovery/test/
+rm -f /storage/external_storage/sdcard1/test*.raw
+
+./boblightd -c boblight.conf
+
+cp /storage/external_storage/sdcard1/boblight-aml .
+./boblight-aml -o gamma=1.75
+
+insmod /storage/external_storage/sdcard1/aml_snapshot.ko
+rmmod  /storage/external_storage/sdcard1/aml_snapshot.ko
+
+cp *.raw /storage/external_storage/sdcard1/
+sync
+
+cat /sys/class/video/axis
+cat /sys/class/aml_snapshot/frame_width
+cat /sys/class/aml_snapshot/frame_height
+cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq
+
+libboblight.so -> /system/lib
+boblight.conf  -> /system/etc
+boblightd      -> /system/bin
+boblight-aml   -> /system/bin
+
+service boblightd /system/bin/boblightd -c /system/etc/boblight.conf
+  user system
+
+service boblight-aml /system/bin/boblight-aml
+  user system
+
+
+*/
--- a/drivers/amlogic/pivos_amsnapshot.old/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/pivos_amsnapshot/Kconfig	2014-12-06 01:13:00.287293988 +0100
@@ -0,0 +1,5 @@
+config PIVOS_AM_SNAPSHOT
+        tristate "Pivos/Amlogic Boblight Support"
+        default n
+        ---help---
+          Select to enable "Pivos/Amlogic Boblight Support.
--- a/drivers/amlogic/pivos_amsnapshot.old/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/pivos_amsnapshot/Makefile	2014-12-06 01:14:03.991291469 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for the pivos/amlogic interface device drivers.
+#
+EXTRA_AFLAGS=-mfloat-abi=softfp -mfpu=neon
+
+obj-$(CONFIG_PIVOS_AM_SNAPSHOT) += aml_snapshot.o
--- a/drivers/amlogic/Makefile.orig	2014-12-06 14:12:21.180401364 +0100
+++ b/drivers/amlogic/Makefile	2014-12-06 14:13:05.995498480 +0100
@@ -125,3 +125,5 @@
 #obj-$(CONFIG_MESON_TRUSTZONE) += trustzone/
 obj-$(CONFIG_MESON_TRUSTZONE) += secure_monitor/
 obj-y += spi/
+
+obj-$(CONFIG_PIVOS_AM_SNAPSHOT) += pivos_amsnapshot/
--- a/include/linux/pivos/aml_snapshot.h.old	1970-01-01 01:00:00.000000000 +0100
+++ b/include/linux/pivos/aml_snapshot.h	2014-12-06 14:22:05.696581561 +0100
@@ -0,0 +1,50 @@
+/*
+ * include/linux/pivos/aml_snapshot.h
+ *
+ * video scaler for thumbnails/snapshots
+ *
+ * Copyright (C) 2013 PivosGroup
+ *
+ * Written by Scott Davilla <scott.davilla@pivosgroup.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD Licence or GNU General Public License
+ * as published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define AMSNAPSHOT_IOC_MAGIC 'T'
+#define AMSNAPSHOT_IOC_GET_FRAME   _IOW(AMSNAPSHOT_IOC_MAGIC, 0x04, unsigned long)
+
+/*  Four-character-code (FOURCC) */
+#define AMSNAPSHOT_FOURCC(a, b, c, d)\
+	((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
+
+#define AMSNAPSHOT_FMT_S24_BGR   AMSNAPSHOT_FOURCC('B', 'G', 'R', '3') /* 24  BGR-8-8-8     */
+#define AMSNAPSHOT_FMT_S24_RGB   AMSNAPSHOT_FOURCC('R', 'G', 'B', '3') /* 24  RGB-8-8-8     */
+#define AMSNAPSHOT_FMT_S32_RGBA  AMSNAPSHOT_FOURCC('R', 'G', 'B', 'A') /* 32  BGR-8-8-8-8   */
+#define AMSNAPSHOT_FMT_S32_BGRA  AMSNAPSHOT_FOURCC('B', 'G', 'R', 'A') /* 32  BGR-8-8-8-8   */
+#define AMSNAPSHOT_FMT_S32_ABGR  AMSNAPSHOT_FOURCC('A', 'B', 'G', 'R') /* 32  BGR-8-8-8-8   */
+#define AMSNAPSHOT_FMT_S32_ARGB  AMSNAPSHOT_FOURCC('A', 'R', 'G', 'B') /* 32  BGR-8-8-8-8   */
+
+struct aml_snapshot_t {
+  unsigned int  src_x;
+  unsigned int  src_y;
+  unsigned int  src_width;
+  unsigned int  src_height;
+  unsigned int  dst_width;
+  unsigned int  dst_height;
+  unsigned int  dst_stride;
+  unsigned int  dst_format;
+  unsigned int  dst_size;
+  unsigned long dst_vaddr;
+};
